<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/ava.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/ava.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/ava.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kenway-20.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="目录基础题 典型题 数据结构设计 解题通用思路 基础题1.传递信息 给定总玩家数n，以及按[玩家编号,对应可传递玩家编号]关系组成的二维数组 relation。返回信息从编号0玩家经过k轮传递到编号为n-1玩家处的方案数；若不能到达，返回0   示例：输入：n &#x3D; 5, relation &#x3D; [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k &#x3D; 3输出：">
<meta property="og:type" content="article">
<meta property="og:title" content="【笔记】算法刷题笔记">
<meta property="og:url" content="http://kenway-20.github.io/2021/03/07/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Kenway&#39;s Blog">
<meta property="og:description" content="目录基础题 典型题 数据结构设计 解题通用思路 基础题1.传递信息 给定总玩家数n，以及按[玩家编号,对应可传递玩家编号]关系组成的二维数组 relation。返回信息从编号0玩家经过k轮传递到编号为n-1玩家处的方案数；若不能到达，返回0   示例：输入：n &#x3D; 5, relation &#x3D; [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k &#x3D; 3输出：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Kenway-20/For-picgo/master/img/%E7%AE%97%E6%B3%951.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Kenway-20/For-picgo/master/img/%E7%AE%97%E6%B3%952.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Kenway-20/For-picgo/master/img/%E7%AE%97%E6%B3%953.jpeg">
<meta property="article:published_time" content="2021-03-06T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-21T03:56:31.121Z">
<meta property="article:author" content="Kenway">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="记录">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Kenway-20/For-picgo/master/img/%E7%AE%97%E6%B3%951.png">

<link rel="canonical" href="http://kenway-20.github.io/2021/03/07/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【笔记】算法刷题笔记 | Kenway's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Kenway's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kenway-20.github.io/2021/03/07/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Kenway">
      <meta itemprop="description" content="这世界上的东西，<br>你不去搬它，它就不动 。<br>一张桌子，你不搬它，它不走;<br>一把茶壶，你不拿它，它起不来。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kenway's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【笔记】算法刷题笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-07 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-07T00:00:00+08:00">2021-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-21 11:56:31" itemprop="dateModified" datetime="2021-07-21T11:56:31+08:00">2021-07-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">工作</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>基础题</p>
<p>典型题</p>
<p>数据结构设计</p>
<p>解题通用思路</p>
<h2 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h2><h3 id="1-传递信息"><a href="#1-传递信息" class="headerlink" title="1.传递信息"></a>1.传递信息</h3><blockquote>
<p>给定总玩家数n，以及按[玩家编号,对应可传递玩家编号]关系组成的二维数组 relation。返回信息从编号0玩家经过k轮传递到编号为n-1玩家处的方案数；若不能到达，返回0</p>
</blockquote>
<blockquote>
<p>示例：输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3<br>输出：3<br>解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。</p>
</blockquote>
<p>解法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int numWays(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relation, int k) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(k+1,vector&lt;int&gt;(n));</span><br><span class="line">    dp[0][0] = 1;</span><br><span class="line">    for(int i = 0; i &lt; k; i++)&#123;</span><br><span class="line">        for(auto t:relation)&#123;</span><br><span class="line">            int start = t[0], target = t[1];</span><br><span class="line">            dp[i+1][target] += dp[i][start]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[k][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"># dp[i][j]表示在第i轮能到达编号j的方案数</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="2-判断链表是否有环-找出链表中环起点问题"><a href="#2-判断链表是否有环-找出链表中环起点问题" class="headerlink" title="2.判断链表是否有环/找出链表中环起点问题"></a>2.判断链表是否有环/找出链表中环起点问题</h3><p>解法:</p>
<ul>
<li>使用快慢指针，慢指针一次走一步，快指针一次走两步，两个指针同时从起点出发，若最后相遇则表示一定有环</li>
<li>相遇时，一个指针原地不动，一个指针指向头节点，然后两个指针偶读改为一次走一步，它们再次相遇的地方就是环的起点</li>
</ul>
<p>证明：设慢指针走了k步与快指针走了2k步在O点相遇，2k-k=k则为环的长度，m为O点与头节点的距离</p>
<p>此时无论是从头结点到环起点，还是O点到环起点的距离都为k-m，所以第二次相遇的地方即为环起点</p>
<h3 id="3-信封嵌套问题"><a href="#3-信封嵌套问题" class="headerlink" title="3.信封嵌套问题"></a>3.信封嵌套问题</h3><blockquote>
<p>即俄罗斯套娃，长、宽都大于才能装进去，求最多能嵌套几层</p>
</blockquote>
<p>解法:</p>
<ul>
<li>以宽度为标准从下到大排序，若宽度相同则比较长度，长度大的在前，长度小的在后</li>
<li>对排好序的数组，以长度为标准求最长递增子序列的长度即为答案</li>
</ul>
<h3 id="4-连续子数组的最大和问题"><a href="#4-连续子数组的最大和问题" class="headerlink" title="4.连续子数组的最大和问题"></a>4.连续子数组的最大和问题</h3><p>解法:</p>
<ul>
<li>dp[i]表示以nums[i]为结尾的连续最大子数组和，注意该和中把nums[i]也算进去了</li>
<li>状态转移方程:dp[i] = max(dp[i-1]+nums[i], nums[i]);</li>
<li>遍历dp[]找出最大值即为答案</li>
</ul>
<h3 id="5-求二叉树最大值-没有负值"><a href="#5-求二叉树最大值-没有负值" class="headerlink" title="5.求二叉树最大值(没有负值)"></a>5.求二叉树最大值(没有负值)</h3><p>解法:</p>
<ul>
<li>采用递归法</li>
<li>自顶向下，主干是根节点与两子树比较<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int maxVal(TreeNode root)&#123;</span><br><span class="line">    if(root == nullptr) return -1;</span><br><span class="line">    int left = maxVal(root-&gt;left);</span><br><span class="line">    int right = maxVal(root-&gt;right);</span><br><span class="line">    return max(root-&gt;val, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-二分查找框架"><a href="#6-二分查找框架" class="headerlink" title="6.二分查找框架"></a>6.二分查找框架</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(left &lt;= right)&#123;</span><br><span class="line">    mid = (right - left) / 2 + left;</span><br><span class="line">    if(nums[mid] &lt; target) left = mid+1;</span><br><span class="line">    else if(nums[mid] &gt; target) right = mid-1;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-有序数组查找最优思路"><a href="#7-有序数组查找最优思路" class="headerlink" title="7.有序数组查找最优思路"></a>7.有序数组查找最优思路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;nums.size();i++) if(nums[i]&gt;=target) return i;</span><br><span class="line">return nums.size();</span><br></pre></td></tr></table></figure>

<h3 id="8-判断正则表达式是否匹配问题"><a href="#8-判断正则表达式是否匹配问题" class="headerlink" title="8.判断正则表达式是否匹配问题"></a>8.判断正则表达式是否匹配问题</h3><blockquote>
<p>s是目标字符串，p是正则表达式</p>
</blockquote>
<ul>
<li>建一个dp函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool dp(string&amp;s, string&amp; p, int i, int j)</span><br></pre></td></tr></table></figure></li>
<li>遍历时分两种情况<ul>
<li>s[i] == p[j] || p[j] == ‘.’<ul>
<li>p[j+1] == ‘*’, return dp(s,p,i+1,j) || dp(s,p,i,j+2)</li>
<li>p[j+1] != ‘*’, return dp(s,p,i+1,j+1)</li>
</ul>
</li>
<li>else<ul>
<li>p[j+1] == ‘*’, return dp(s,p,i,j+2)</li>
<li>else return false;</li>
</ul>
</li>
</ul>
</li>
<li>加上特殊情况判定<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(j == p.size()) return i == s.size();</span><br><span class="line">if(i == s.size())&#123;</span><br><span class="line">    if((p.size()-j) % 2 == 1) return false;</span><br><span class="line">    for(; j+1 &lt; n; j+=2) if(p[j+1] != &#x27;*&#x27;) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-原地移动零"><a href="#9-原地移动零" class="headerlink" title="9.原地移动零"></a>9.原地移动零</h3><blockquote>
<p>给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序</p>
</blockquote>
<p>解法:</p>
<ul>
<li>left指针左边是已经处理好的序列，right右边是未处理的序列,left应该指向一个0</li>
<li>right和left之间全是0</li>
<li>一旦right指到一个非0的数，就交换right与left指到的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int left = 0, right = 0;</span><br><span class="line">while(right &lt; nums.size())&#123;</span><br><span class="line">    if(nums[right] != 0) &#123;</span><br><span class="line">        swap(nums[left], nums[right]);</span><br><span class="line">        left++;</span><br><span class="line">        &#125;</span><br><span class="line">    right++;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br></pre></td></tr></table></figure>
(还有一个双层遍历的方法，即一旦指到0就去后面找非0的和它交换，较简单不再赘叙)</li>
</ul>
<h3 id="10-买卖股票最佳时机系列问题"><a href="#10-买卖股票最佳时机系列问题" class="headerlink" title="10.买卖股票最佳时机系列问题"></a>10.买卖股票最佳时机系列问题</h3><blockquote>
<p>初阶:给定一个数组prices，它的第i个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0。</p>
</blockquote>
<p>解法：dp[i]表示在i天卖出能获得的最大利润,min_p存的是i天之前最低的买入价格</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(prices.size() &lt;= 1) return 0;</span><br><span class="line">vector&lt;int&gt; dp(prices.size());</span><br><span class="line">int min_p = prices[0];</span><br><span class="line">dp[1] = -1;</span><br><span class="line">int ans = INT_MIN;</span><br><span class="line">for(int i = 1; i &lt; prices.size(); i++)&#123;</span><br><span class="line">    dp[i] = prices[i] - min_p;</span><br><span class="line">    ans = max(dp[i], ans);</span><br><span class="line">    min_p = min(prices[i], min_p);</span><br><span class="line">&#125;</span><br><span class="line">if(ans &lt; 0) return 0;</span><br><span class="line">return ans;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进阶1:你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p>解法:<br>一、贪心思想</p>
<ul>
<li>每次遇到上坡都买入、卖出</li>
<li>最后收益一定是最大值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">for(int i = 0; i &lt; prices.size()-1; i++)&#123;</span><br><span class="line">    if(prices[i] &lt; prices[i+1])&#123; </span><br><span class="line">    sum += prices[i+1] - prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>二、动态规划</p>
<ul>
<li>dp[i][0]表示在i天手上没有股票的最高收益，dp[i][1]表示在i天手上有股票的最高收益</li>
<li>遍历天数时更新dp[i][0]和dp[i][1]</li>
<li>最后返回dp[prices.size()-1][0]，因为此时没有股票一定比有股票收益大</li>
<li>亮点在于最大利润里未来支付的概念，即买股票就直接扣，卖出去的时候就直接加，而不用去管具体差值得到的利润到底是多少，max()动态规划过程会自动计算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2));</span><br><span class="line">dp[0][0] = 0;</span><br><span class="line">dp[0][1] = -prices[0];</span><br><span class="line">for(int i = 1; i &lt; prices.size(); i++)&#123;</span><br><span class="line">    dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);</span><br><span class="line">    dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);</span><br><span class="line">&#125;</span><br><span class="line">return dp[prices.size()-1][0];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进阶2:卖出股票后，你无法在第二天买入股票(即冷冻期为1天)。<br>解法：动态规划</p>
</blockquote>
<ul>
<li>同进阶1类似，不同的是多一个状态dp[i][2]表示i天处于冷冻期的最大收益</li>
<li>注意结果要比较处于冷冻期和不处于冷冻期的情况，取较大值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt; (3));</span><br><span class="line">dp[0][1] = -prices[0]; </span><br><span class="line">for(int i = 1; i &lt; prices.size(); i++)&#123;</span><br><span class="line">    dp[i][0] = max(dp[i-1][0], dp[i-1][2]);</span><br><span class="line">    dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);</span><br><span class="line">    dp[i][2] = dp[i-1][1] + prices[i];</span><br><span class="line">&#125;</span><br><span class="line">return max(dp[prices.size()-1][0], dp[prices.size()-1][2]);</span><br><span class="line"></span><br><span class="line"># dp[i][0]是手上无股票且不处于冷冻期的最大收益</span><br><span class="line"># dp[i][1]是手上有股票的最大收益</span><br><span class="line"># dp[i][2]是手上无股票且处于冷冻期的最大收益</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进阶3:没有冷冻期，一次完整买入卖出需要fee手续费</p>
</blockquote>
</li>
<li>用动态规划法，修改卖出时的公式即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - fee);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-打家劫舍系列问题"><a href="#11-打家劫舍系列问题" class="headerlink" title="11.打家劫舍系列问题"></a>11.打家劫舍系列问题</h3><blockquote>
<p>初阶:你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<p>解法:dp[i]表示偷i号房屋前提下能获得的最大利润</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; dp(nums.size());</span><br><span class="line">dp[0] = nums[0];</span><br><span class="line">if(nums.size() == 1) return dp[0];</span><br><span class="line">dp[1] = nums[1];</span><br><span class="line">if(nums.size() == 2) return max(dp[0], dp[1]);</span><br><span class="line">dp[2] = nums[0] + nums[2];</span><br><span class="line">int ans = max(dp[1], dp[2]);</span><br><span class="line">for(int i = 3; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    dp[i] = max(dp[i-2], dp[i-3]) + nums[i];</span><br><span class="line">    ans = max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">return ans;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进阶1:增加条件-首尾房子连在一起，即不能同时偷第一间和最后一间</p>
</blockquote>
<p>解法:</p>
<ul>
<li>分成两种情况<ul>
<li>房子序列中没有最后一间</li>
<li>房子序列中没有第一间</li>
</ul>
</li>
<li>用初阶的代码分别求出两种情况的最大利润，然后返回最大值即可</li>
</ul>
<blockquote>
<p>进阶2:从二叉树偷，两个直接相连的房子不能同时偷(即父树与子树不能同时偷)</p>
</blockquote>
<p>解法:</p>
<ul>
<li>用一个int box(TreeNode* root)函数作递归</li>
<li>核心函数结构<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int box(TreeNode* root)&#123;</span><br><span class="line">    if(root == nullptr) return 0;</span><br><span class="line">    int do_it = root-&gt;val + box(root-&gt;left-&gt;left) + box(root-&gt;left-&gt;right) + box(root-&gt;right-&gt;left) + box(root-&gt;right-&gt;right);</span><br><span class="line">    int do_not = box(root-&gt;left) + box(root-&gt;right);</span><br><span class="line">    return max(do_it, do_not);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># do_it是偷该层, do_not是不偷该层</span><br><span class="line"># box()实际上就是表示以该点为根节点的最大利润</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12-背包问题的固定框架"><a href="#12-背包问题的固定框架" class="headerlink" title="12.背包问题的固定框架"></a>12.背包问题的固定框架</h3><ul>
<li>dp[i][w]表示对前i个物品进行选择，且当前背包容量为w时，能装下的最大价值</li>
<li>核心<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][w]=max(dp[i-1][w], dp[i-1][w-wt[i-1]] + val[i-1])</span><br><span class="line"></span><br><span class="line"># dp[i-1][w]是不装当前物品</span><br><span class="line"># dp[i-1][w-wt[i-1]] + val[i-1]是装当前物品，i-1是因为下标从0开始的，wt是重量数组，val是价值数组</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>背包问题重要特性</strong>(由它们的dp意义不同造成的)</p>
<ul>
<li>若dp[i][j]表示的是最大价值，则用max()选dp[i][j]，且第二个值为dp[i-1][xx]</li>
<li>若dp[i][j]表示能不能装进背包，则用||来组成dp[i][j]，且第二个值为[i-1][xx]</li>
<li>若dp[i][j]表示的是方法数，则用+来组成dp[i][j]，且第二个值为dp[i][xx]，因为此时dp[i][xx]包含了dp[i-1][xx-nums[i]]</li>
<li>第一个值永远是dp[i-1][j]</li>
</ul>
<p>变形题目:一个数组能不能分成两个和相等的子集</p>
<ul>
<li>容量 = 整个数组和/2，dp[i][j]表示前i个物品能恰好填满容量为j的背包(即dp[i][j] = true，其他全初始化为false)</li>
<li>核心代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(j - nums[j-1] &lt; 0) dp[i][j] = dp[i-1][j];</span><br><span class="line">else dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[j-1]];</span><br><span class="line"></span><br><span class="line"># j - nums[j-1] &lt; 0表示物品大于背包容量，直接不能装</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-零钱兑换问题"><a href="#13-零钱兑换问题" class="headerlink" title="13.零钱兑换问题"></a>13.零钱兑换问题</h3><blockquote>
<p>给定一个coins数组表示零钱的面额种类，每种零钱可以无限个使用</p>
</blockquote>
<p>解法:与背包问题框架类似</p>
<ul>
<li>dp[i][j]表示仅用前i种面额钱币时能凑出金额j的方法数(base:dp[i][0] = 1,其它全初始化为0)</li>
<li>核心代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(j-coins[i-1] &lt; 0) dp[i][j] = dp[i-1][j];</span><br><span class="line">else dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="14-跳跃游戏系列问题"><a href="#14-跳跃游戏系列问题" class="headerlink" title="14.跳跃游戏系列问题"></a>14.跳跃游戏系列问题</h3><blockquote>
<p>初阶:给定一个非负整数数组nums，你最初位于数组的第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p>
</blockquote>
<p>解法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int max_step = 0;</span><br><span class="line">for(int i = 0; i &lt; nums.size()-1; i++)&#123;</span><br><span class="line">    max_step = max(max_step, i + nums[i]);</span><br><span class="line">    if(max_step &lt;= i) return false;</span><br><span class="line">&#125;</span><br><span class="line">if(max_step &gt;= nums.size()-1) return true;</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line"># max_step是全局最远能走多远</span><br><span class="line"># max_step &lt;= i是表示碰到0卡住了，永远走不到下一步</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进阶:使用最少的跳跃次数到达数组的最后一个位置，求最少跳跃次数</p>
</blockquote>
<p>解法:</p>
<p>一、贪心思想</p>
<ul>
<li>farest表示下标[i,….,end]中能走得最远的距离</li>
<li>if(i == end) 表示的是这一段的[i,….,end]已经遍历结束，要开始进行跳跃(count++)，最远可以跳到farest，并将end更新为farest，由于此时i = end，实际上就是将[i,….,end]更新为[end,…,farest]</li>
<li>一旦到达末尾，马上结束循环并返回跳跃次数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">if(nums.size() == 1) return count;</span><br><span class="line">int end = 0;</span><br><span class="line">int farest = 0;</span><br><span class="line">for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    farest = max(farest, i + nums[i]);</span><br><span class="line">    if(i == end)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        end = farest;</span><br><span class="line">        if(farest&gt;=nums.size()-1) break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>二、动态规划(简单，但会超时)</p>
<ul>
<li>dp(nums, index)表示从index到nums的最小跳跃次数</li>
<li>dp()函数的思路是遍历从index能走到(nums[index])的每一个位置，看哪个位置能用最少跳跃到末尾</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; memo;</span><br><span class="line">int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    memo = vector&lt;int&gt;(nums.size(), nums.size());</span><br><span class="line">    return dp(nums, 0);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">int dp(vector&lt;int&gt;&amp; nums, int index)&#123;</span><br><span class="line">    if(memo[index] != nums.size()) return memo[index];</span><br><span class="line">    int n = nums.size()-1;</span><br><span class="line">    if(index &gt;= n) return 0;</span><br><span class="line">    for(int i = 1; i &lt;= nums[index]; i++)&#123;</span><br><span class="line">        int temp = dp(nums, index+i);</span><br><span class="line">        memo[index] = min(memo[index], temp+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return memo[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-子数组的最大和系列问题"><a href="#15-子数组的最大和系列问题" class="headerlink" title="15.子数组的最大和系列问题"></a>15.子数组的最大和系列问题</h3><blockquote>
<p>初阶:给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int dp = 0;</span><br><span class="line">int max_ans = INT_MIN;</span><br><span class="line">for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    dp = max(dp + nums[i], nums[i]);</span><br><span class="line">    max_ans = max(dp, max_ans);</span><br><span class="line">&#125;</span><br><span class="line">    return max_ans;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进阶:数组改为环形数组，即首尾连起来，且连续子数组里同一元素只能出现一次，返回最大和</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Kenway-20/For-picgo/master/img/%E7%AE%97%E6%B3%951.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 计算无环的情况</span><br><span class="line">int dp = 0;</span><br><span class="line">int max_ans = INT_MIN;</span><br><span class="line">int max_num = INT_MIN;</span><br><span class="line">for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    dp = max(dp + nums[i], nums[i]);</span><br><span class="line">    max_ans = max(dp, max_ans);</span><br><span class="line">    max_num = max(nums[i], max_num);</span><br><span class="line">&#125;</span><br><span class="line"># max_num用来识别全是负数的情况，需要特殊处理</span><br><span class="line">if(max_num &lt; 0) return max_num;</span><br><span class="line"></span><br><span class="line"># 计算有环的情况</span><br><span class="line"># 先求出连续子数组最小值，然后用sum去减就得到最大值</span><br><span class="line">dp = 0;</span><br><span class="line">int min_ans = INT_MAX;</span><br><span class="line">int sum = 0;</span><br><span class="line">for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    sum += nums[i];</span><br><span class="line">    dp = min(dp + nums[i], nums[i]);</span><br><span class="line">    min_ans = min(dp, min_ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 返回两种情况中的最大值</span><br><span class="line">max_ans = max(max_ans, sum - min_ans);</span><br><span class="line">return max_ans;</span><br></pre></td></tr></table></figure>

<h3 id="16-回溯法经典模板"><a href="#16-回溯法经典模板" class="headerlink" title="16.回溯法经典模板:"></a>16.回溯法经典模板:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void backtrack(当前路径，选择列表)&#123;</span><br><span class="line">    if(满足结束条件)&#123;</span><br><span class="line">        reslut.add(当前路径);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for 选择 in 选择列表&#123;</span><br><span class="line">        描述做选择的语句;</span><br><span class="line">        backtrack(做完选择后的当前路径，还可选择的列表);</span><br><span class="line">        撤销选择(例:当前路径.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-无重复字符的最长子串"><a href="#17-无重复字符的最长子串" class="headerlink" title="17.无重复字符的最长子串"></a>17.无重复字符的最长子串</h3><blockquote>
<p>给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。<br>解法:</p>
</blockquote>
<ul>
<li>用双指针形成一个滑动窗口</li>
<li>用一个哈希表window来记录当前窗口内字符串的出现次数</li>
<li>right遍历到不重复字符时，window[s[right]]++，right++</li>
<li>right遍历到重复的字符时，left缩小，window[s[left]]++，left++直到重复字符消失<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if(s.size() == 0) return 0;</span><br><span class="line">unordered_map&lt;char, int&gt; window;</span><br><span class="line">int left = 0, right = 0;</span><br><span class="line">int ans = 0;</span><br><span class="line">while(right &lt; s.size())&#123;</span><br><span class="line">    if(window[s[right]] == 0)&#123;</span><br><span class="line">        window[s[right]]++;</span><br><span class="line">        right++;</span><br><span class="line">        ans = max(ans, right-left);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        while(s[left] != s[right])&#123;</span><br><span class="line">            window[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        window[s[left]]--;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18-乘积最大子数组"><a href="#18-乘积最大子数组" class="headerlink" title="18.乘积最大子数组"></a>18.乘积最大子数组</h3><blockquote>
<p>给你一个整数数组nums，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
</blockquote>
<p>解法:维持两个变量max_dp、min_dp</p>
<ul>
<li>本题难点在于原本最小的负数乘另一个负数就变成了很大的正数，很大的数乘一个负数就变成最小的数</li>
<li>解法是维持两个变量max_dp、min_dp，分别代表当前最大乘积和当前最小乘积</li>
<li>每次遍历都更新一次</li>
<li>如何保证用的值都是连续的子数组呢，一是顺序遍历，二则关键在于选择时多了一个nums[i]，它表示有可能从这里抛开前面的子数组，重新开始算<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(nums.size() == 0) return 0;</span><br><span class="line">if(nums.size() == 1) return nums[0];</span><br><span class="line">int min_dp = nums[0];</span><br><span class="line">int max_dp = nums[0];</span><br><span class="line">int ans = nums[0];</span><br><span class="line">for(int i = 1; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    int temple = max_dp;</span><br><span class="line">    max_dp = max(max(nums[i], nums[i]*temple), nums[i]*min_dp);</span><br><span class="line">    min_dp = min(min(nums[i], nums[i]*min_dp), nums[i]*temple);</span><br><span class="line">    ans = max(max_dp, ans);</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line"></span><br><span class="line"># 每次更新的max_dp、min_dp都是一样的，都是在nums[i]、nums[i]*max_dp和nums[i]*min_dp中去选，只不过一个用max()，一个用min()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="19-合并二叉树"><a href="#19-合并二叉树" class="headerlink" title="19.合并二叉树"></a>19.合并二叉树</h3><p>解法：</p>
<ul>
<li>若两个都有值就新建节点处理</li>
<li>若其中一个为nullptr就返回另一个<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">    if(root1 == nullptr &amp;&amp; root2 == nullptr) return nullptr;</span><br><span class="line">    else if(root1 == nullptr &amp;&amp; root2 != nullptr) return root2;</span><br><span class="line">    else if(root1 != nullptr &amp;&amp; root2 == nullptr) return root1;</span><br><span class="line">    TreeNode* merge = new TreeNode(root1-&gt;val + root2-&gt;val);</span><br><span class="line">    merge-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class="line">    merge-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br><span class="line">    return merge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="20-单词的拆分"><a href="#20-单词的拆分" class="headerlink" title="20.单词的拆分"></a>20.单词的拆分</h3><blockquote>
<p>给定一个非空字符串s和一个包含非空单词的列表wordDict，判定s是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
</blockquote>
<blockquote>
<p>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>     注意你可以重复使用字典中的单词。</p>
</blockquote>
<p>解法：动态规划</p>
<ul>
<li>dp[i]表示s[0….i-1]可以被拆分成字典里的单词</li>
<li>双层遍历i=[1,s.size()],j=[0,i]</li>
<li>所以答案就是dp[s.size()]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;bool&gt; dp(s.size()+1);</span><br><span class="line">unordered_map&lt;string, int&gt; f;</span><br><span class="line">for(auto t:wordDict) f[t] = 1;</span><br><span class="line">dp[0] = true;</span><br><span class="line">for(int i = 1; i &lt;= s.size(); i++)&#123;</span><br><span class="line">    for(int j = 0; j &lt; i; j++)&#123;</span><br><span class="line">        string str1 = s.substr(j, i-j);</span><br><span class="line">        dp[i] =  dp[j] &amp;&amp; f[str1] == 1;</span><br><span class="line">        if(dp[i]) break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[s.size()];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="21-等差数列的划分"><a href="#21-等差数列的划分" class="headerlink" title="21.等差数列的划分"></a>21.等差数列的划分</h3><blockquote>
<p>输入：nums = [1, 2, 3, 4]<br>输出：3  即[1, 2, 3], [2, 3, 4],[1, 2, 3, 4]</p>
</blockquote>
<p>解法：用动态规划</p>
<ul>
<li>dp[i]表示以nums[i]结尾的等差数列的数量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(nums.size() &lt; 3) return 0;</span><br><span class="line">vector&lt;int&gt; dp(nums.size());</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 2; i &lt; nums.size();i++)&#123;</span><br><span class="line">    if(nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) dp[i] = dp[i-1] + 1;</span><br><span class="line">    ans += dp[i];</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line"></span><br><span class="line"># dp[i] = dp[i-1] + 1;是因为一旦符合前面的等差，那就在dp[i-1]的基础上+1</span><br><span class="line"># 如果nums[i-3,i-2,i-1]不是等差的话，那dp[i-1]=0,dp[i] = 0+1也没错</span><br><span class="line"># 该解法也考虑了等差差值不同的情况</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="22-二维数组中的高效查找"><a href="#22-二维数组中的高效查找" class="headerlink" title="22.二维数组中的高效查找"></a>22.二维数组中的高效查找</h3><blockquote>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。</p>
</blockquote>
<p>解法</p>
<ul>
<li>从右上角开始</li>
<li>matrix[i][j] &gt; target就往左移</li>
<li>matrix[i][j] &lt; target就往下移<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if(matrix.size() == 0 || matrix[0].size() == 0) return false;</span><br><span class="line">int n = matrix.size();</span><br><span class="line">int m = matrix[0].size();</span><br><span class="line">int i = 0, j = m-1;</span><br><span class="line">while(1)&#123;</span><br><span class="line">    if(matrix[i][j] &gt; target)&#123;</span><br><span class="line">        j--;</span><br><span class="line">        if(j &lt; 0) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(matrix[i][j] &lt; target)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        if(i &gt;= n) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else return true;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="23-全组合问题"><a href="#23-全组合问题" class="headerlink" title="23.全组合问题"></a>23.全组合问题</h3><blockquote>
<p>给一个数字n，和一个数组大小k，要求在[1….n]中选数字组成大小为k的数组，返回所有可能性，不能有重复(数字顺序不同算一个数组)</p>
</blockquote>
<p>解法:回溯法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">    vector&lt;int&gt; temple;</span><br><span class="line">    backtrack(n,k,1,temple);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(int&amp; n, int&amp; k, int step, vector&lt;int&gt; temple)&#123;</span><br><span class="line">    if(temple.size() &gt;= k)&#123;</span><br><span class="line">        ans.push_back(temple);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = step; i &lt;= n; i++)&#123;</span><br><span class="line">        temple.push_back(i);</span><br><span class="line">        backtrack(n,k,i+1,temple);</span><br><span class="line">        temple.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 开销较大</span><br><span class="line"># 优化思路:将传入vector&lt;int&gt;temple改为传入temple的当前下标；将temple全局声明，然后局部定义它的大小，这样就不用push)back()了</span><br></pre></td></tr></table></figure>

<h3 id="24-全排列问题"><a href="#24-全排列问题" class="headerlink" title="24.全排列问题"></a>24.全排列问题</h3><blockquote>
<p>给一个数组，返回它的不同顺序组合</p>
</blockquote>
<p>解法：回溯法(这个需要传vector<int>作为参数)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; track;</span><br><span class="line">    backtrack(nums, track, 0);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void backtrack(vector&lt;int&gt;&amp; nums, vector&lt;int&gt; track, int step)&#123;</span><br><span class="line">    if(track.size() == nums.size()) ans.push_back(track);</span><br><span class="line">    for(int i = step; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        if(find(track.begin(), track.end(), nums[i]) != track.end()) continue;</span><br><span class="line">        track.push_back(nums[i]);</span><br><span class="line">        backtrack(nums, track, 0);</span><br><span class="line">        track.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种比较暴力的回溯法是直接用nums疯狂swap，每次的结果用哈希表记录，将不重复的压入ans，开销和上面这种一样</p>
<h3 id="25-翻转二叉树"><a href="#25-翻转二叉树" class="headerlink" title="25.翻转二叉树"></a>25.翻转二叉树</h3><p>解法：递归</p>
<ul>
<li>从叶节点开始翻转</li>
<li>当前节点左右子树都交换位置后，才将当前节点与另一个节点交换位置</li>
<li>当遇到某节点为nullptr时，直接return nullptr递归会自动处理<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">    if (root == nullptr) &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># 进行递归翻转</span><br><span class="line">    TreeNode* left = invertTree(root-&gt;left);</span><br><span class="line">    TreeNode* right = invertTree(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = right;</span><br><span class="line">    root-&gt;right = left;</span><br><span class="line">    return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="26-杨辉三角"><a href="#26-杨辉三角" class="headerlink" title="26.杨辉三角"></a>26.杨辉三角</h3><blockquote>
<p>返回杨辉三角的第rowIndex行</p>
</blockquote>
<p>解法:</p>
<ul>
<li>亮点在于用一个dp数组迭代，空间开销小<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; dp(rowIndex);</span><br><span class="line">for(int i = 0 ; i &lt; rowIndex;i++)&#123;</span><br><span class="line">    int pre = 1;</span><br><span class="line">    for(int j = 0; j &lt;= i; j++)&#123;</span><br><span class="line">        int temple = dp[j];</span><br><span class="line">        if(j == 0 || j == i) dp[j] = 1;</span><br><span class="line">        else dp[j] += pre;</span><br><span class="line">        pre = temple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp;</span><br></pre></td></tr></table></figure>
若是求前n个数组的话，将每次i循环结束得到的结果依次push进答案数组即可</li>
</ul>
<h3 id="27-剪绳子系列问题"><a href="#27-剪绳子系列问题" class="headerlink" title="27.剪绳子系列问题"></a>27.剪绳子系列问题</h3><blockquote>
<p>有一根长为n的绳子，可将它剪成很多子绳，求它的最大子绳乘积</p>
</blockquote>
<p>解法:</p>
<p>一、数学法</p>
<ul>
<li>由数学定义可证明<ul>
<li>当剩余绳子长度大于等于5时，尽可能的剪出长度为3的子绳</li>
<li>当绳子长度为4时，剪也可不剪也可</li>
<li>当绳子长度小于4时，不剪</li>
<li>如此子绳乘积最大</li>
</ul>
</li>
</ul>
<p>二、动态规划法</p>
<ul>
<li>dp[i]表示长度为i的绳子子绳最大乘积</li>
<li>用双层遍历来更新dp[n] = max(dp(i)*dp(n-i)，dp[n])</li>
<li>从小到大开始遍历</li>
<li>注意<ul>
<li>n=2,3时特殊处理</li>
<li>dp[1] = 1,dp[2] = 2, dp[3]=3是base方便后面算法，但此时dp并不代表i的最大乘积</li>
</ul>
</li>
</ul>
<h3 id="28-判断是否是2的幂"><a href="#28-判断是否是2的幂" class="headerlink" title="28.判断是否是2的幂"></a>28.判断是否是2的幂</h3><p>解法:<br>一、用二进制能表示的最大2的幂对n取余</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return (n &gt; 0) &amp;&amp; (1&lt;&lt;30) % n == 0;</span><br></pre></td></tr></table></figure>
<p>二、用n与n的补码相&amp;看是否等于n</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return (n &gt; 0) &amp;&amp; (n &amp; -n) == n;</span><br></pre></td></tr></table></figure>
<p>三、常规递归/2看能不能除尽</p>
<h3 id="29-计算二进制中1的个数"><a href="#29-计算二进制中1的个数" class="headerlink" title="29.计算二进制中1的个数"></a>29.计算二进制中1的个数</h3><p>解法:</p>
<ul>
<li>即每次都判断最后一位是不是二进制<ul>
<li>是，counter+1</li>
<li>不是，counter+0</li>
<li>然后n往右移一位</li>
</ul>
</li>
<li>当n==0时退出循环<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int counter = 0;</span><br><span class="line">while(n)&#123;</span><br><span class="line">    counter = counter + n % 2;</span><br><span class="line">    n = n &gt;&gt; 1;</span><br><span class="line">&#125;</span><br><span class="line">return counter;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="30-二叉搜索树中的搜索"><a href="#30-二叉搜索树中的搜索" class="headerlink" title="30.二叉搜索树中的搜索"></a>30.二叉搜索树中的搜索</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* searchBST(TreeNode* root, int val) &#123;</span><br><span class="line">    if(root == nullptr) return nullptr;</span><br><span class="line">    if(root-&gt;val == val ) return root;</span><br><span class="line">    else if(root -&gt; val &lt; val) return searchBST(root-&gt;right, val);</span><br><span class="line">    else return searchBST(root-&gt;left, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="31-只出现一次的数字"><a href="#31-只出现一次的数字" class="headerlink" title="31.只出现一次的数字"></a>31.只出现一次的数字</h3><blockquote>
<p>除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素</p>
</blockquote>
<p>解法:位运算</p>
<ul>
<li>与自己异或等于0</li>
<li>0与某数异或结果仍为某数</li>
<li>异或满足交换律</li>
<li>所以答案就是全数组每个元素异或的结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int ans = nums[0];</span><br><span class="line">for(int i = 1; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    ans = ans ^ nums[i];</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="32-二叉搜索树的最近公共祖先"><a href="#32-二叉搜索树的最近公共祖先" class="headerlink" title="32.二叉搜索树的最近公共祖先"></a>32.二叉搜索树的最近公共祖先</h3><p>解法：</p>
<ul>
<li>如果当前节点值同时大于p、q，则当前节点移到它的左子树</li>
<li>如果当前节点值同时小于p、q，则当前节点移到它的右子树</li>
<li>否则则说明当前节点时分叉口(包含了当前节点时p、q的情况)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) return lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">    else if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) return lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">    else return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="典型题"><a href="#典型题" class="headerlink" title="典型题"></a>典型题</h2><h3 id="1-求小岛数量"><a href="#1-求小岛数量" class="headerlink" title="1.求小岛数量"></a>1.求小岛数量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1],</span><br><span class="line">[0,1,1],</span><br><span class="line">[1,0,0]]</span><br><span class="line"></span><br><span class="line"># 0表示水，1表示陆地</span><br><span class="line"># 该实例答案为2</span><br></pre></td></tr></table></figure>
<p>解法:</p>
<ul>
<li>main()中双层循环遍历，每遇到一个1就调用一次dfs()且ans++</li>
<li>dfs()中将数过的1变为0，然后对其上、下、左、右再分别判断，若为1就继续调用dfs()</li>
<li>main()双层循环外return ans</li>
</ul>
<blockquote>
<p>进阶：找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。如上例中应该返回面积为3。</p>
</blockquote>
<p>解法：和初阶基本一样，也是数过就改为0并遍历周围元素</p>
<ul>
<li>亮点是返回int类型函数的递归使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int max_ans = 0;</span><br><span class="line">int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    for(int i = 0; i &lt; grid.size(); i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; grid[0].size(); j++)&#123;</span><br><span class="line">            if(grid[i][j] == 0) continue;</span><br><span class="line">            max_ans = max(max_ans, box(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max_ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int box(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    if(grid[i][j] == 1)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        grid[i][j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else return 0;</span><br><span class="line">    </span><br><span class="line">    # 根据周围土地情况更新这块岛屿总面积</span><br><span class="line">    if(i+1 &lt; grid.size()) ans += box(grid, i+1, j);</span><br><span class="line">    if(j+1 &lt; grid[0].size()) ans += box(grid, i, j+1);</span><br><span class="line">    if(i-1 &gt;= 0) ans += box(grid, i-1, j);</span><br><span class="line">    if(j-1 &gt;= 0) ans += box(grid, i, j-1);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-找出一个数组里的峰值元素"><a href="#2-找出一个数组里的峰值元素" class="headerlink" title="2.找出一个数组里的峰值元素"></a>2.找出一个数组里的峰值元素</h3><blockquote>
<p>即前后元素都比它要小,不存在nums[i]==nums[i+1],nums[0]和nums[nums.size()-1]视为负无穷大</p>
</blockquote>
<p>解法：</p>
<ul>
<li>遍历数组nums:当nums[i] &gt; nums[i+1]时，return nums[i]</li>
<li>若遍历结束仍未有符合条件nums[i]返回，则return nums[nums.size()-1]</li>
</ul>
<h3 id="3-判断s中含有t的所有字符的最小子串问题"><a href="#3-判断s中含有t的所有字符的最小子串问题" class="headerlink" title="3.判断s中含有t的所有字符的最小子串问题"></a>3.判断s中含有t的所有字符的最小子串问题</h3><p>类似问题：找所有字母异位词、最长无重复子串、判断s中是否有某个子串是t的某全排列问题</p>
<p>解法：</p>
<ul>
<li>使用滑动窗口，新建两个哈希表need(t中含有字符)、window(当前窗口含有字符)，用下述语句判断当前窗口是否符合要求<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(auto&amp; i:need) if(window[i.first]&lt;i.second) return false</span><br><span class="line">return true</span><br></pre></td></tr></table></figure></li>
<li>符合就left+1，直到不符合，记录；不符合就right+1，直到再一次符合并重复上述循环(直到遍历到s末尾)</li>
</ul>
<h3 id="4-求数组它的最长递增子序列"><a href="#4-求数组它的最长递增子序列" class="headerlink" title="4.求数组它的最长递增子序列"></a>4.求数组它的最长递增子序列</h3><blockquote>
<p>子序列即为可以不连续的子数组</p>
</blockquote>
<p>解法：</p>
<ul>
<li>用动态规划，dp[i]表示以nums[i]这个数结尾的最长递增子序列长度</li>
<li>核心代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    for(int j = 0; j &lt; i; j++)&#123;   </span><br><span class="line">        if(nums[i]&gt;nums[j]) dp[i] = max(dp[i], dp[j]+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-求两字符串的最长公共子序列问题"><a href="#5-求两字符串的最长公共子序列问题" class="headerlink" title="5.求两字符串的最长公共子序列问题"></a>5.求两字符串的最长公共子序列问题</h3><p>类似问题：连线不能相交问题</p>
<p>解法:</p>
<ul>
<li>dp[i][j]表示str1[0,1,…,i-1]与str2[0,1,…,j-1]的最长公共子序列长度(当i或j任一为0时，dp[i][j]=0，因为””与任何字符串的公共子序列长度都为0)</li>
<li>判断<ul>
<li>如果str1[i]==str2[j]，即两个str前进一步的字符相同，那么该字符肯定在公共子序列lcs里<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1] + 1;</span><br></pre></td></tr></table></figure></li>
<li>如果str1[i]!=str2[j]，那么又分两种情况<ul>
<li>str1[i]在lcs里<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-1];</span><br></pre></td></tr></table></figure></li>
<li>str2[j]在lcs里<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j];</span><br></pre></td></tr></table></figure></li>
<li>综上可得当str1[i]!=str2[j]时<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i][j-1], dp[i-1][j]);</span><br><span class="line">    </span><br><span class="line"># 不用考虑str1[i]和str2[j]都不在lcs的情形，因为max取大值，不影响结果</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>结果为dp[str1.size()][str2.size()]</li>
</ul>
<h3 id="6-编辑距离题目"><a href="#6-编辑距离题目" class="headerlink" title="6.编辑距离题目"></a>6.编辑距离题目</h3><blockquote>
<p>有两个字符串s1和s2，求将s1变成s2需要多少步操作?</p>
</blockquote>
<p>解法:</p>
<p>一、 递归法</p>
<ul>
<li>用i、j分别指向s1、s2字符串末端</li>
<li>若s1[i]==s2[j]，i和j都前进一步，return box(i-1, j-1)</li>
<li>若s1[i]!=s2[j]，有三种可能进行的变换<ul>
<li>删除，box(i-1, j)+1</li>
<li>插入，box(i, j-1)+1</li>
<li>替换，box(i-1, j-1)+1</li>
</ul>
  用min()来取三者中最小的那个</li>
<li>前面加两个判断，适用于其中一个字符串已经数到末尾了，后面的操作全是插入或删除  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(i ==-1) return j+1;</span><br><span class="line">if(j == -1) return i+1;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>二、dp数组法(开销和递归法用备忘录优化后一样)</p>
<ul>
<li>dp[i][j]表示s1[0,…,i-1]变成s2[0,…,j-1]所需的最短步数</li>
<li>赋值dp[i][0]=i, dp[0][j]=j</li>
<li>双层循环嵌套:1&lt;=i&lt;=s1.size(), 1&lt;=j&lt;=s2.size()  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 表示不需要操作，直接到下一步</span><br><span class="line">if(s1[i-1] == s2[j-1]) dp[i][j] = dp[i-1][j-1];</span><br><span class="line"></span><br><span class="line">else dp[i][j] = min(删除，插入，替换);</span><br></pre></td></tr></table></figure></li>
<li>最终答案为dp[s1.size()][s2.size()]</li>
</ul>
<h3 id="7-最长回文子序列解法"><a href="#7-最长回文子序列解法" class="headerlink" title="7.最长回文子序列解法:"></a>7.最长回文子序列解法:</h3><ul>
<li>dp[i][j]表示从s[i]到s[j]包含的最长回文子序列长度，可得dp[i][j]=1,dp[i][j]=0(i&gt;j时)</li>
<li>反着遍历  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i=s.size()-1; i &gt;= 0; i--)&#123;</span><br><span class="line">    for(j = i+1; j &lt; s.size();j++)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 外层其实可以从s.size()-2开始,因为s.size()-1没意义</span><br></pre></td></tr></table></figure></li>
<li>base是dp[i][i] =1;</li>
<li>核心代码:<ul>
<li>如果s[i]==s[j]则表示在dp[i+1][j-1]的基础上又多了两个回文字符<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i+1][j-1] + 2;</span><br></pre></td></tr></table></figure></li>
<li>如果s[i]!=s[j]则表示这一步没能增加回文字符，于是选取上一步中最大的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i+1][j], dp[i][j-1]);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>最后答案就是dp[0][s.size()-1]<blockquote>
<p>进阶:让字符串成为回文串的最小插入次数<br>解法：</p>
</blockquote>
</li>
<li>只需改成即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(s[i] == s[j]) dp[i][j] = dp[i+1][j-1];</span><br><span class="line">else dp[i][j] = min(dp[i+1][j], dp[i][j-1])+1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-最长回文子串"><a href="#8-最长回文子串" class="headerlink" title="8.最长回文子串"></a>8.最长回文子串</h3><p>解法:</p>
<ul>
<li>用for去遍历一次字符串</li>
<li>每个字符放入expensed()去得到以它为中心的最长扩展字符串<ul>
<li>expand(s, i, i);</li>
<li>expand(s, i, i+1);</li>
</ul>
</li>
<li>亮点expand接受的是左右指针，是字符串的时候分别–和++<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int ans_start = 0, ans_end = 0;</span><br><span class="line">string longestPalindrome(string s) &#123;</span><br><span class="line">    for(int i = 0; i &lt; s.size()-1; i++)&#123;</span><br><span class="line">        if(i&gt;= (ans_end-ans_start)/2 &amp;&amp; s.size()-i &gt;= (ans_end-ans_start)/2)&#123;</span><br><span class="line">            expand(s,i,i);</span><br><span class="line">            expand(s,i,i+1);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s.substr(ans_start, ans_end-ans_start+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void expand(string&amp; s, int left, int right)&#123;</span><br><span class="line">    while(left&gt;=0 &amp;&amp; right&lt;s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">        left--;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    left++;</span><br><span class="line">    right--;</span><br><span class="line">    if(right - left &gt; ans_end-ans_start)&#123;</span><br><span class="line">        ans_start = left;</span><br><span class="line">        ans_end = right;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-旋转数组"><a href="#9-旋转数组" class="headerlink" title="9.旋转数组"></a>9.旋转数组</h3><blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数，要求使用空间复杂度为O(1)的原地算法</p>
</blockquote>
<p>解法:<br>一、环形替代</p>
<ul>
<li>从nums[0]开始寻找它的下一个位置，使nums[next] = nums[0]</li>
<li>同时将nums[next]原来的值记录下来，并去找它的下一个位置</li>
<li>一次while循环结束后检查count是否为len</li>
<li>若不为len则表示有的数还没进行位置更新</li>
<li>进入下一个i的for循环<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int len  = nums.length;</span><br><span class="line">k = k % len;</span><br><span class="line">int count = 0;         // 记录交换位置的次数，n个同学一共需要换n次</span><br><span class="line">for(int start = 0; count &lt; len; start++) &#123;</span><br><span class="line">    int cur = start;       // 从0位置开始换位子</span><br><span class="line">    int pre = nums[cur];   </span><br><span class="line">    do&#123;</span><br><span class="line">        int next = (cur + k) % len;</span><br><span class="line">        int temp = nums[next];    // 来到角落...</span><br><span class="line">        nums[next] = pre;</span><br><span class="line">        pre = temp;</span><br><span class="line">        cur = next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;while(start != cur)  ;     // 循环暂停，回到起始位置，角落无人</span><br><span class="line">            </span><br></pre></td></tr></table></figure></li>
</ul>
<p>二、取巧翻转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int n = nums.size();</span><br><span class="line">if(n==1 || k == 0 || k == n) return;</span><br><span class="line">k = k % n;</span><br><span class="line">reverse(&amp;nums[0], &amp;nums[n]);</span><br><span class="line">reverse(&amp;nums[0], &amp;nums[k]);</span><br><span class="line">reverse(&amp;nums[k], &amp;nums[n]);</span><br><span class="line">return;</span><br></pre></td></tr></table></figure>

<h3 id="10-删除并获得点数"><a href="#10-删除并获得点数" class="headerlink" title="10.删除并获得点数"></a>10.删除并获得点数</h3><blockquote>
<p>给你一个整数数组nums，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i]，删除它并获得nums[i]的点数。之后，你必须删除所有等于nums[i]-1和nums[i]+1的元素。</p>
</blockquote>
<p>解法:</p>
<ul>
<li>由”删除所有等于nums[i]-1和nums[i]+1的元素”联想到与打家劫舍不能偷相邻屋子有异曲同工之妙</li>
<li>将nums数组用哈希表记录下来，并构建成一个打家劫舍的数组house</li>
<li>用打家劫舍的方法解出来<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;int, int&gt; f;</span><br><span class="line">int max_p = INT_MIN;</span><br><span class="line">for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    f[nums[i]]++;</span><br><span class="line">    max_p = max(max_p, nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; house(max_p+1);</span><br><span class="line">for(int i = 0; i &lt; max_p+1; i++)&#123;</span><br><span class="line">    house[i] = i * f[i];</span><br><span class="line">        &#125;</span><br><span class="line">vector&lt;int&gt; dp(max_p+1);</span><br><span class="line">dp[0] = house[0];</span><br><span class="line">if(house.size() == 1) return dp[0];</span><br><span class="line">dp[1] = house[1];</span><br><span class="line">if(house.size() == 2) return max(dp[0], dp[1]);</span><br><span class="line">dp[2] = house[0] + house[2];</span><br><span class="line">int ans = max(dp[1], dp[2]);</span><br><span class="line">for(int i = 3; i &lt; house.size(); i++)&#123;</span><br><span class="line">    dp[i] = max(dp[i-2], dp[i-3]) + house[i];</span><br><span class="line">    ans = max(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-高楼扔鸡蛋问题"><a href="#11-高楼扔鸡蛋问题" class="headerlink" title="11. 高楼扔鸡蛋问题"></a>11. 高楼扔鸡蛋问题</h3><blockquote>
<p>你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层0&lt;=F&lt;=N，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于F的楼层都不会碎）。现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层F呢？</p>
</blockquote>
<p>解法:</p>
<ul>
<li>核心循环<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 1; i &lt; n+1; i++)&#123;</span><br><span class="line">    ans = min(ans, 碎和不碎中最坏情况);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># min表示在该次选择中，选哪层楼是最优解</span><br></pre></td></tr></table></figure></li>
<li>碎和不碎<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">碎和不碎 = max(dp(k, n-i), dp(k, i-1))+1;</span><br><span class="line"></span><br><span class="line"># dp(k, n-i)表示鸡蛋没碎，下一步把i层看作0层再实验</span><br><span class="line"># dp(K, i-1)表示鸡蛋碎了</span><br><span class="line"># max表示选择的是最坏的情况</span><br></pre></td></tr></table></figure></li>
<li>加上base case<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(k == 1) return n; // 只有一个鸡蛋只能从0层开始线性搜索</span><br><span class="line">if(n == 0) return 0;</span><br></pre></td></tr></table></figure></li>
<li>优化思路:<ul>
<li>核心for循环改成二分搜索，碎了right = mid - 1，没碎left = mid + 1</li>
<li>增加一个备忘录来记录已经算过的dp(k,n)</li>
</ul>
</li>
</ul>
<p>另一种解法:</p>
<ul>
<li>dp[k][m]表示有k个鸡蛋，尝试扔了m次能测的楼层数(答案即为dp[k][m]=n时，m的值)</li>
<li>核心代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while(dp[k][m]&lt;n)&#123;</span><br><span class="line">    m++; //增加m的值来逼近n</span><br><span class="line">    for(int i = 1; i &lt;= k; i++)&#123;</span><br><span class="line">        dp[i][m] = dp[i][m-1] + dp[i-1][m-1] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># dp[i][m-1]没碎，表示下面的楼层</span><br><span class="line"># + 1加的是本楼层 </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12-戳气球问题"><a href="#12-戳气球问题" class="headerlink" title="12.戳气球问题"></a>12.戳气球问题</h3><blockquote>
<p>有n个气球，编号为0到n-1，每个气球上都标有一个数字，这些数字存在数组 nums中。现在要求你戳破所有的气球。戳破第i个气球，你可以获得nums[i-1]*nums[i]*nums[i+1]枚硬币。这里的i-1和i+1代表和i相邻的两个气球的序号。如果i-1或 i+1超出了数组的边界，那么就当它是一个数字为1的气球。求所能获得硬币的最大数量。</p>
</blockquote>
<p>解法:</p>
<ul>
<li>dp[i][j]表示戳破i与j之间所有的气球得到的最高分(不戳破i和j)，所有要把原数组开头和末尾加一个值为1的元素，即构建新数组new_nums，new_nums.size() = nums.size()+2</li>
<li>作选择时假设最后戳破的气球是第k个，则dp[i][j] = dp[i][k] + dp[k][j] + 得分计算公式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int k = i+1; k &lt; j; k++)&#123;</span><br><span class="line">    int temple = dp[i][k] + dp[k][j] + 得分计算公式;</span><br><span class="line">    dp[i][j] = max(dp[i][j], temple);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 用max()和for遍历i与j之间所有k的可能，最后得到正确的dp[i][j]</span><br></pre></td></tr></table></figure></li>
<li>答案即为dp[0][new_nums.size()-1]</li>
</ul>
<h3 id="13-目标和问题"><a href="#13-目标和问题" class="headerlink" title="13.目标和问题"></a>13.目标和问题</h3><blockquote>
<p>给每个元素分配”+”、”-“，求最后和为target的组合方式数</p>
</blockquote>
<p>解法:</p>
<p>一、回溯法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void backtrack(int i, int target)&#123;</span><br><span class="line">    if(target == 0) ans++;</span><br><span class="line">    if(i &gt;= nums.size()) return;</span><br><span class="line">    # 假设为nums[i]分配+</span><br><span class="line">    backtrack(i+1, target+nums[i]);</span><br><span class="line">    # 假设为nums[i]分配-</span><br><span class="line">    backtrack(i+1, target-nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、数学法:</p>
<ul>
<li>将nums分为a与b两部分，由sum(a) - sum(b) = target 推导出sum(a) = (target + sum(b) + sum(a) / 2</li>
<li>于是就转换成了子集和为sum(a)的组合方式有多少种的背包问题</li>
<li>dp[i][j]表示仅使用前i个物品的某几个恰好能填满容量为j的背包的方法数</li>
<li>核心代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(j - nums[j-1] &lt; 0) dp[i][j] = dp[i-1][j];</span><br><span class="line">else dp[i][j] = dp[i-1][j] + dp[i-1][j - nums[j-1]];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="14-乘积为正数的最长子数组长度"><a href="#14-乘积为正数的最长子数组长度" class="headerlink" title="14.乘积为正数的最长子数组长度"></a>14.乘积为正数的最长子数组长度</h3><p>解法：比较有意思的题，针对负数和0的情况分别处理</p>
<ul>
<li>代码包括主过程的for循环遍历g[]和一个调用函数max_lens()</li>
<li>for循环遍历含有所有零下标的g[]，分别将其切分成多个不含零的连续子数组</li>
<li>max_lens(vector<int>&amp; nums)则是算出传进来的子数组的乘积为正数的最长子数组长度(此时的子数组一定不含0，降低了处理难度)</li>
<li>关键在于max_lens()中要根据负数的奇偶分情况<ul>
<li>负数个数为偶数，返回nums.size()</li>
<li>负数个数为奇数，不要第一个负数和不要最后一个负数两种情况，哪种的子数组最长就取哪种<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int getMaxLen(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; g;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 0; i &lt; nums.size();i++) if(nums[i] == 0) g.push_back(i);</span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    for(auto&amp; t:g)&#123;</span><br><span class="line">        right = t;</span><br><span class="line">        vector&lt;int&gt;::const_iterator First = nums.begin() + left;</span><br><span class="line">        vector&lt;int&gt;::const_iterator Second = nums.begin() + right;</span><br><span class="line">        vector&lt;int&gt; new_nums(First, Second);</span><br><span class="line">        ans = max(ans, max_lens(new_nums));</span><br><span class="line">        left = right + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(g.size() == 0) ans = max_lens(nums);</span><br><span class="line">    else if(left &lt; nums.size())&#123;</span><br><span class="line">        vector&lt;int&gt;::const_iterator First = nums.begin() + left;</span><br><span class="line">        vector&lt;int&gt;::const_iterator Second = nums.end();</span><br><span class="line">        vector&lt;int&gt; new_nums(First, Second);</span><br><span class="line">        ans = max(ans, max_lens(new_nums));</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int max_lens(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    vector&lt;int&gt; f;</span><br><span class="line">    for(int i = 0; i &lt; nums.size();i++) if(nums[i] &lt; 0) f.push_back(i);</span><br><span class="line">    int n = f.size();</span><br><span class="line">    if(n % 2 == 0) return nums.size();</span><br><span class="line">    else&#123;</span><br><span class="line">        int left = f[f.size()-1] - f[0] + nums.size()-1 - f[f.size()-1];</span><br><span class="line">        int right = f[f.size()-1] - f[0] + f[0];</span><br><span class="line">        return max(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="15-最佳观光组合"><a href="#15-最佳观光组合" class="headerlink" title="15.最佳观光组合"></a>15.最佳观光组合</h3><blockquote>
<p>给你一个正整数数组 values，其中 values[i] 表示第i个观光景点的评分，一对景点（i &lt; j）组成的观光组合的得分为values[i]+values[j]+i-j，也就是景点的评分之和减去它们两者之间的距离。返回一对观光景点能取得的最高分。</p>
</blockquote>
<p>解法：</p>
<ul>
<li>第一反应用双层遍历 ans = max(ans,values[i]+values[j]+i-j)，但明显开销太大</li>
<li>进一步想values[j]-j是固定的常数，而i属于[0, j-1]之间，只要在遍历j的时候更新values[i]+i的最大值就可以最终得到答案</li>
<li>亮点在如何通过values[i]+values[j]+i-j联想到遍历j的同时更新i的相关值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int dp = values[0] + 0;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 1; i &lt; values.size(); i++)&#123;</span><br><span class="line">    ans = max(ans, dp + values[i] - i);</span><br><span class="line">    dp = max(dp, values[i] + i);</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br></pre></td></tr></table></figure>

<h3 id="16-接雨水"><a href="#16-接雨水" class="headerlink" title="16.接雨水"></a>16.接雨水</h3><p>解法：</p>
<p>一、辅助数组法</p>
<ul>
<li>事先计算出两个辅助数组left_max和right_max，left_max[i]表示height[0…i-1]的最大值，right_max[i]表示height[i+1….height.size()-1]的最大值</li>
<li>则i处可接雨水为min(left_max[i],right_max[i]) - height[i]</li>
<li>最后答案就是遍历求和</li>
</ul>
<p>二、双指针巧妙法</p>
<ul>
<li>定义left和right分别指向height首尾</li>
<li>在while中更新left_max和right_max值，它们分别代表左右指针遍历到当前状态时数过的最大值</li>
<li>每次while循环计算一次，谁的最大值小就计算谁，然后谁那边就往里缩<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int n = height.size();</span><br><span class="line">if(n &lt; 3) return 0;</span><br><span class="line">int left = 0, right = n-1;</span><br><span class="line">int ans = 0;</span><br><span class="line">int left_max = INT_MIN, right_max = INT_MIN;</span><br><span class="line">while(left != right)&#123;</span><br><span class="line">    left_max = max(left_max, height[left]);</span><br><span class="line">    right_max = max(right_max, height[right]);</span><br><span class="line">    if(left_max &lt; right_max)&#123;</span><br><span class="line">        # 此时虽然max_right并不一定是height[left]右边的最大值，可能是第二大、第三大....，但是既然不是最大值都比left_max大，那最大值一定比left_max大</span><br><span class="line">        # 又因为计算ans只用到min(left_max, right_max(实际最大值))，所有可以直接计算该处能接多少雨水，else同</span><br><span class="line">        ans += left_max - height[left];</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        ans += right_max - height[right];</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="17-解码方法"><a href="#17-解码方法" class="headerlink" title="17.解码方法"></a>17.解码方法</h3><blockquote>
<p>一条包含字母 A-Z 的消息通过以下映射进行了编码：<br>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>例如，”11106” 可以映射为：<br>    “AAJF” ，将消息分组为 (1 1 10 6)<br>    “KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” </p>
</blockquote>
<p>解法:动态规划</p>
<ul>
<li>dp[i]表示前i个成员能组成几种映射</li>
<li>亮点在于<ul>
<li>如果s[i] != ‘0’,那么dp[i]初始值就是dp[i-1]</li>
<li>如果s[i-1]、s[i]能组成合法字符，那么dp[i]就得在初始值的基础上再加上dp[i-2]</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool break_flag  = false;</span><br><span class="line">int numDecodings(string s) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(s.size());</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    if(s[0] == &#x27;0&#x27;) return 0;</span><br><span class="line">    for(int i = 1; i&lt;s.size();i++)&#123;</span><br><span class="line">        if(s[i] != &#x27;0&#x27;)  dp[i] = dp[i-1];</span><br><span class="line">        if(isValid(s[i-1], s[i]) &amp;&amp; i &gt;= 2) dp[i] += dp[i-2];</span><br><span class="line">        if(isValid(s[i-1], s[i]) &amp;&amp; i == 1) dp[i] += 1;</span><br><span class="line">        if(break_flag) return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isValid(char t1, char t2)&#123;</span><br><span class="line">    if(t1 == &#x27;1&#x27;) return true;</span><br><span class="line">    if(t1 == &#x27;2&#x27; &amp;&amp; t2 &lt;= &#x27;0&#x27; + 6) return true;</span><br><span class="line">    if(t2 == &#x27;0&#x27;) break_flag = true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># break_flag用于判别“1304”、“801”这种不能映射的非法输入</span><br></pre></td></tr></table></figure>

<h3 id="18-判断是否是丑数"><a href="#18-判断是否是丑数" class="headerlink" title="18.判断是否是丑数"></a>18.判断是否是丑数</h3><blockquote>
<p>丑数是只含1,2,3,5质因数的数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; factors = &#123;2, 3, 5&#125;;</span><br><span class="line">    for (int factor : factors) &#123;</span><br><span class="line">        while (n % factor == 0) &#123;</span><br><span class="line">            n /= factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">return n == 1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进阶:求第n个丑数<br>解法:</p>
</blockquote>
<ul>
<li>不能用一个个判断，开销太大</li>
<li>维护三个指针p2、p3、p5</li>
<li>dp[i]表示第i-1个丑数(因为dp[0]是第一个丑数)</li>
<li>用min()取dp[p2]*2，dp[p3]*3，dp[p5]*5中最小的一个作为dp[i]，并把对应p指针++<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; dp(n);</span><br><span class="line">dp[0] = 1;</span><br><span class="line">int p2 = 0, p3 = 0, p5 = 0;</span><br><span class="line">int i = 1;</span><br><span class="line">while(i &lt;= n-1)&#123;</span><br><span class="line">    int num2=dp[p2]*2, num3=dp[p3]*3, num5=dp[p5]*5;</span><br><span class="line">    int temple = min(min(num2, num3), num5);</span><br><span class="line">    if(temple == num2) p2++;</span><br><span class="line">    if(temple == num3) p3++;</span><br><span class="line">    if(temple == num5) p5++;</span><br><span class="line">    dp[i++] = temple;</span><br><span class="line">&#125;</span><br><span class="line">return dp[n-1];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="19-求不同的二叉搜索树数目"><a href="#19-求不同的二叉搜索树数目" class="headerlink" title="19.求不同的二叉搜索树数目"></a>19.求不同的二叉搜索树数目</h3><blockquote>
<p>求恰由n个节点组成且节点值从1到n互不相同的二叉搜索树有多少种？</p>
</blockquote>
<p>解法:抽象变成动态规划问题</p>
<ul>
<li>本题关键不在二叉搜索树，而在不同的树数目</li>
<li>dp[i]表示由i个节点构成的不同二叉搜索树数目<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; dp(n+1);</span><br><span class="line"></span><br><span class="line"># 显然节点为0时或1个时，只有一种可能</span><br><span class="line">dp[0] = 1;</span><br><span class="line">dp[1] = 1;</span><br><span class="line">for(int i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">    for(int j = 0;j &lt; i; j++)&#123;</span><br><span class="line">        dp[i] += dp[j]*dp[i-1-j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[n];</span><br><span class="line"></span><br><span class="line"># dp[j]中j是左子树的节点数，即dp[j]表示的是左子树不同数目</span><br><span class="line"># dp[i-1-j]中j是右子树的节点数，即dp[i-1-j]表示的是右子树不同数目，总节点数为i-1是因为根节点要用掉一个节点</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="20-矩阵中的路径"><a href="#20-矩阵中的路径" class="headerlink" title="20.矩阵中的路径"></a>20.矩阵中的路径</h3><blockquote>
<p>给定一个m x n二维字符网格board和一个字符串word 。如果word存在于网格中返回true ；否则，返回false(不能重复用)</p>
</blockquote>
<p>解法:暴力遍历加记录走过路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">    int n = board.size(), m = board[0].size();</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; m;j++)&#123;</span><br><span class="line">            if(board[i][j] == word[0])&#123;</span><br><span class="line">            if(isTrue(board,word,i,j,0)) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isTrue(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int i, int j, int w_i)&#123;</span><br><span class="line">    if(w_i &gt;= word.size()) return true;</span><br><span class="line">    if(i &lt; 0 || i &gt;= board.size() || j &lt; 0 || j &gt;= board[0].size()) return false;</span><br><span class="line">    if(board[i][j] != word[w_i]) return false;</span><br><span class="line">    char temple = board[i][j];</span><br><span class="line">    board[i][j] = &#x27;0&#x27;;</span><br><span class="line">    bool ans = isTrue(board,word, i-1,j,w_i+1) || isTrue(board,word, i,j-1,w_i+1) || isTrue(board,word, i+1,j,w_i+1) || isTrue(board,word, i,j+1,w_i+1);</span><br><span class="line">    board[i][j] = temple;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 将board[i][j]变成&#x27;0&#x27;后又变回来，是为了在一次递归中不走重复路，因为&#x27;0&#x27;不会与字符串匹配成功</span><br></pre></td></tr></table></figure>

<h3 id="21-全为1的正方形的最大面积"><a href="#21-全为1的正方形的最大面积" class="headerlink" title="21.全为1的正方形的最大面积"></a>21.全为1的正方形的最大面积</h3><blockquote>
<p>在一个由’0’和’1’组成的二维矩阵内，找到只包含’1’的最大正方形，并返回其面积</p>
</blockquote>
<p>解法:暴力遍历</p>
<ul>
<li>虽然是暴力遍历，但是因为剪枝做得好，时间空间开销都极小</li>
<li>维护一个全局变量max_d表示当前遍历过的全为1的正方形最大的边</li>
<li>这样每次检测的时候就从max_d+1开始检测</li>
<li>再加上检测end_i、end_j只要一个越界立即返回<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int max_d = 0;</span><br><span class="line">int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    for(int i = 0; i &lt; matrix.size(); i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; matrix[0].size(); j++)&#123;</span><br><span class="line">            if(matrix[i][j] == &#x27;1&#x27;)&#123;</span><br><span class="line">                max_d = max(max_d, 1);</span><br><span class="line">                isValid(matrix, i, j, max_d+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max_d * max_d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void isValid(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, int i, int j, int d)&#123;</span><br><span class="line">    int end_i = i + d -1, end_j = j + d -1;</span><br><span class="line">    if(end_i &gt;= matrix.size() || end_j &gt;= matrix[0].size()) return;</span><br><span class="line">    for(int t1 = i; t1 &lt;= end_i; t1++)&#123;</span><br><span class="line">        for(int t2 = j; t2 &lt;= end_j; t2++)&#123;</span><br><span class="line">            if(matrix[t1][t2] == &#x27;0&#x27;) return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max_d = max(max_d, d);</span><br><span class="line">    isValid(matrix, i, j, d+1);</span><br><span class="line">    return;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><h3 id="1-实现一个LRU缓存"><a href="#1-实现一个LRU缓存" class="headerlink" title="1.实现一个LRU缓存"></a>1.实现一个LRU缓存</h3><p>解法:</p>
<ul>
<li>由一个哈希表 + 一个双向链表实现<ul>
<li>哈希表&lt;int, node&gt;提供快速访问，int是键</li>
<li>双向链表每个节点有int key, int val, next指针和prev指针提供顺序，key是键</li>
</ul>
</li>
<li>尾部的是最近使用的，头部的是最近未使用的</li>
<li>访问某节点时<ul>
<li>当前链表中存在，将其放到尾部</li>
<li>当前链表中不存在，插入到尾部，检查若链表size已满就把头部节点删除</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"># 定义双向链表的节点结构</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int key, val;</span><br><span class="line">    Node *next;</span><br><span class="line">    Node *prev;</span><br><span class="line">    Node(int k, int v)&#123;</span><br><span class="line">        this-&gt;key = k;</span><br><span class="line">        this-&gt;val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 定义双向链表结构和一些方法，方便后续在LRU中实例化一个双向链表</span><br><span class="line">class DoubleList&#123;</span><br><span class="line">    private: </span><br><span class="line">    Node *head;</span><br><span class="line">    Node *tail;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    public:</span><br><span class="line">    DoubleList()&#123;</span><br><span class="line">        head = new Node(0,0);</span><br><span class="line">        tail = new Node(0,0);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addLast(Node *x)&#123;</span><br><span class="line">        if(x == nullptr) return;</span><br><span class="line">        x -&gt; prev = tail -&gt; prev;</span><br><span class="line">        x -&gt; next = tail;</span><br><span class="line">        tail-&gt;prev-&gt;next = x;</span><br><span class="line">        tail-&gt;prev = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void remove(Node *x)&#123;</span><br><span class="line">        if(x == nullptr) return;</span><br><span class="line">        x -&gt; prev -&gt; next = x -&gt;next;</span><br><span class="line">        x -&gt; next -&gt; prev = x -&gt; prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node* removefirst()&#123;</span><br><span class="line">        if(head == tail) return nullptr;</span><br><span class="line">        Node *p =head-&gt;next;</span><br><span class="line">        remove(head-&gt;next);</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int length()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># LRU主要逻辑</span><br><span class="line">class LRUCache &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, Node*&gt;map;</span><br><span class="line">    DoubleList cache;</span><br><span class="line">    int cap;</span><br><span class="line">public:</span><br><span class="line">    LRUCache(int capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">        unordered_map&lt;int, Node*&gt;map;</span><br><span class="line">        DoubleList cache;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void makeup(int key)&#123;</span><br><span class="line">        Node *p = map[key];</span><br><span class="line">        cache.remove(p);</span><br><span class="line">        cache.addLast(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if(map.count(key) == 0) return -1;</span><br><span class="line">        makeup(key);</span><br><span class="line">        if(map[key] == nullptr) return -1;</span><br><span class="line">        return map[key]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void insert(int key, int value)&#123;</span><br><span class="line">        Node *p = new Node(key, value);</span><br><span class="line">        cache.addLast(p);</span><br><span class="line">        map[key] = p;</span><br><span class="line">        if(cache.length() &gt; cap) removeLeast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if(map.count(key) == 0) insert(key, value);</span><br><span class="line">        cache.remove(map[key]);</span><br><span class="line">        insert(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void removeLeast()&#123;</span><br><span class="line">        Node *p = cache.removefirst();</span><br><span class="line">        map.erase(p-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 用法</span><br><span class="line"># LRUCache* obj = new LRUCache(capacity);</span><br><span class="line"># int param_1 = obj-&gt;get(key);</span><br><span class="line"># obj-&gt;put(key,value);</span><br></pre></td></tr></table></figure>

<h3 id="2-实现一个LFU缓存"><a href="#2-实现一个LFU缓存" class="headerlink" title="2.实现一个LFU缓存"></a>2.实现一个LFU缓存</h3><p>解法:</p>
<ul>
<li>满时删除访问次数(freq变量)最少的节点，若有多个相同节点则删除醉最旧的那个</li>
<li>第一个哈希表&lt;int,int&gt;存key到val的映射</li>
<li>第二个哈希表&lt;int,int&gt;存key到freq的映射</li>
<li>第三个哈希表&lt;int,LinkedHashSet<int>&gt; 存freq到freq相同的key列表映射</li>
<li>一个哈希链表LinkedHashSet<int>存key列表的同时具有时间顺序(哈希链表=哈希表+双向链表)</li>
</ul>
<h3 id="3-用栈实现一个队列"><a href="#3-用栈实现一个队列" class="headerlink" title="3.用栈实现一个队列"></a>3.用栈实现一个队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 要点：数据结构栈写在private里，MyQueue()里不需要写代码</span><br><span class="line"></span><br><span class="line">class MyQueue &#123;</span><br><span class="line">private:</span><br><span class="line">        stack&lt;int&gt; s1;</span><br><span class="line">        stack&lt;int&gt; s2;</span><br><span class="line">public:</span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(s2.empty())&#123;</span><br><span class="line">            while(!s1.empty())&#123;</span><br><span class="line">            s2.push(s1.top());</span><br><span class="line">            s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int temple = s2.top();</span><br><span class="line">        s2.pop();</span><br><span class="line">        return temple;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int peek() &#123;</span><br><span class="line">        if(s2.empty())&#123;</span><br><span class="line">            while(!s1.empty())&#123;</span><br><span class="line">            s2.push(s1.top());</span><br><span class="line">            s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return s1.empty() &amp;&amp; s2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解题通用思路"><a href="#解题通用思路" class="headerlink" title="解题通用思路"></a>解题通用思路</h2><p>1.求公共前缀(字符串仅由a-z组成)取巧方法：先对每个字符串sort排序，排序后第一个字符串与最后一个字符串的公共前缀就是所有字符串的最长公共前缀</p>
<p>2.判断二叉树是否为对称二叉树时，用递归：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box(TreeNode* zuo, TreeNode* you)&#123;</span><br><span class="line">return zuo-&gt;val == you-&gt;val &amp;&amp; box(zuo-&gt;left, you-&gt;right) &amp;&amp; box(zuo-&gt;right, you-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.求一个字符串内无重复的最长子串，用滑动窗口法：定义两个指针，当下一个遍历字符不在窗口内时，右指针++，当下一个遍历字符在窗口内时左指针加到老字符不存在窗口为止，记录下过程中出现的最大结果，遍历完成返回最大结果</p>
<p>4.盛最多水容器问题，用双指针：初始left=0，right=nums.size()-1,然后比较nums[left]和nums[right]，哪个小哪个指针就往内缩，记录下过程中出现的最大结果，遍历完成返回最大结果</p>
<p>5.对于首尾不能同时存在的问题，最优解决办法是分别求出没有首和没有尾两种情况的结果，再比较两个结果哪个更符合题意</p>
<p>6.对无序链表进行排序</p>
<ul>
<li>box():用快慢指针将链表分成两段</li>
<li>merge():将两个有序链表合并成一个更长的有序链表</li>
<li>在box()里面写成return merge(box(第一段), box(第二段))</li>
</ul>
<p>7.异或题重要规律</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a^b = b^a</span><br><span class="line">a^a = 0</span><br><span class="line">a^0 = a</span><br><span class="line">a^b = c =&gt; a^c = b</span><br></pre></td></tr></table></figure>

<p>8.涉及异或数组的问题，首先想到用前缀和异或数组来作辅助</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xor[i] = 0, i == 0时</span><br><span class="line">xor[i] = arr[i-1]^xor[i-1], i &gt; 0时</span><br><span class="line"># arr[]是题目给的用来异或的数组</span><br><span class="line"># 即xor[i] = arr[0]^......^ar</span><br></pre></td></tr></table></figure>

<p>9.宽度搜索(bfs)核心思想</p>
<ul>
<li>该层全部压入队列</li>
<li>然后一次弹出</li>
<li>每个弹出的节点延伸的子节点全压入队列</li>
</ul>
<p>双向bfs</p>
<ul>
<li> 奇数次扩散从起点开始，偶数次扩散从终点开始</li>
<li> 直到两个方向的扩散出现交集</li>
</ul>
<p>10.一旦设计子序列和最值，一定考动态规划，时间复杂度一般都要为O(n平方)，即都要用双层嵌套为核心循环</p>
<p>11.组合、排列、子集问题记得用回溯法，套下面的框架</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># track一般是一个vector数组</span><br><span class="line">for()&#123;</span><br><span class="line">    track.push_back(num[i]);</span><br><span class="line">    box(track,....);</span><br><span class="line">    track.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>12.要求原地修改数组的题目，正着遍历困难的话，不妨试着从数组末尾开始更新元素</p>
<p>13.最小花费爬楼梯题目，错误思路是贪心，正确思路是dp[i]表示到达i层所需的最小花费即dp[i] = min(dp[i-1], dp[i-2])</p>
<p>14.有时候不清楚二维dp数组的遍历方向，不妨看看最终答案应该返回dp的哪个下标，由下标逆推出遍历方向</p>
<p>15.状态压缩技巧：改变遍历的顺序就可以用到上一次循环中的老数据。例如：dp[i-1][j-1]这个数，若i正遍历，j倒遍历，则用dp[j-1]即可取代，因为在给dp[j-1]更新值前，它里面存的是上一个i的dp[j-1]</p>
<p>16.组合、排列、子集问题用回溯法，灵活使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for()&#123;</span><br><span class="line">    track.push_back(num[i]);</span><br><span class="line">    box(track,...);</span><br><span class="line">    track.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似框架</p>
<p>17.腐烂的橘子类型题目一般用BFS解</p>
<ul>
<li>先找到起始所有腐烂的橘子</li>
<li>然后循环处理，把新腐烂的橘子加入下一次循环的队列中</li>
<li>当下一次循环的队列为空时，说明不能继续腐烂了，判断一下还有没有新鲜的橘子，<ul>
<li>如果有，就返回-1(表示这个新鲜的橘子永远不能腐烂)</li>
<li>如果没有，就返回循环的次数(一般就是答案)</li>
</ul>
</li>
</ul>
<p>18.二叉树的三种遍历方向</p>
<ul>
<li>前序遍历：节点-&gt;左子树-&gt;右子树</li>
<li>中序遍历：左子树-&gt;节点-&gt;右子树</li>
<li>后序遍历：左子树-&gt;右子树-&gt;节点</li>
</ul>
<p>19.面积和思路(一般用于矩形求子矩形内之和要用到前缀和数组的题目)</p>
<p>S(O,D)=S(O,C)+S(O,B)−S(O,A)+D<br><img src="https://raw.githubusercontent.com/Kenway-20/For-picgo/master/img/%E7%AE%97%E6%B3%952.jpeg"></p>
<p>S(A,D)=S(O,D)−S(O,E)−S(O,F)+S(O,G)<br><img src="https://raw.githubusercontent.com/Kenway-20/For-picgo/master/img/%E7%AE%97%E6%B3%953.jpeg"></p>
<p>20.状态压缩一定是先写出二维数组存数据的解法，然后观察才能得到状态压缩法的，不可能一来直接写出状态压缩。很多解题思路也是这样，先写出暴力遍历法，再去优化</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag"><i class="fa fa-tag"></i> 技术</a>
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
              <a href="/tags/%E8%AE%B0%E5%BD%95/" rel="tag"><i class="fa fa-tag"></i> 记录</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/20/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92%E4%BC%A0%E6%92%AD%E6%A8%A1%E6%8B%9F%E7%A8%8B%E5%BA%8F%E6%80%9D%E8%B7%AF/" rel="prev" title="【实战】新冠病毒传播模拟程序思路">
      <i class="fa fa-chevron-left"></i> 【实战】新冠病毒传播模拟程序思路
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/20/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%E6%9E%84%E5%BB%BA%E5%B0%8F%E8%A7%84%E6%A8%A1%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" rel="next" title="【实战】构建小规模知识图谱并实现可视化">
      【实战】构建小规模知识图谱并实现可视化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-text">目录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%A2%98"><span class="nav-text">基础题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF"><span class="nav-text">1.传递信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF-%E6%89%BE%E5%87%BA%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E8%B5%B7%E7%82%B9%E9%97%AE%E9%A2%98"><span class="nav-text">2.判断链表是否有环&#x2F;找出链表中环起点问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98"><span class="nav-text">3.信封嵌套问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98"><span class="nav-text">4.连续子数组的最大和问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%80%BC-%E6%B2%A1%E6%9C%89%E8%B4%9F%E5%80%BC"><span class="nav-text">5.求二叉树最大值(没有负值)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A1%86%E6%9E%B6"><span class="nav-text">6.二分查找框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE%E6%9C%80%E4%BC%98%E6%80%9D%E8%B7%AF"><span class="nav-text">7.有序数组查找最优思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%88%A4%E6%96%AD%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%98%AF%E5%90%A6%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="nav-text">8.判断正则表达式是否匹配问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%8E%9F%E5%9C%B0%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="nav-text">9.原地移动零</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-text">10.买卖股票最佳时机系列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-text">11.打家劫舍系列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%9B%BA%E5%AE%9A%E6%A1%86%E6%9E%B6"><span class="nav-text">12.背包问题的固定框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98"><span class="nav-text">13.零钱兑换问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-text">14.跳跃游戏系列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-text">15.子数组的最大和系列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%BB%8F%E5%85%B8%E6%A8%A1%E6%9D%BF"><span class="nav-text">16.回溯法经典模板:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-text">17.无重复字符的最长子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">18.乘积最大子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">19.合并二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E5%8D%95%E8%AF%8D%E7%9A%84%E6%8B%86%E5%88%86"><span class="nav-text">20.单词的拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E7%9A%84%E5%88%92%E5%88%86"><span class="nav-text">21.等差数列的划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%AB%98%E6%95%88%E6%9F%A5%E6%89%BE"><span class="nav-text">22.二维数组中的高效查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-%E5%85%A8%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="nav-text">23.全组合问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-text">24.全排列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">25.翻转二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="nav-text">26.杨辉三角</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-%E5%89%AA%E7%BB%B3%E5%AD%90%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-text">27.剪绳子系列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF2%E7%9A%84%E5%B9%82"><span class="nav-text">28.判断是否是2的幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-%E8%AE%A1%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">29.计算二进制中1的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="nav-text">30.二叉搜索树中的搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">31.只出现一次的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-text">32.二叉搜索树的最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98"><span class="nav-text">典型题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%B1%82%E5%B0%8F%E5%B2%9B%E6%95%B0%E9%87%8F"><span class="nav-text">1.求小岛数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%89%BE%E5%87%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E9%87%8C%E7%9A%84%E5%B3%B0%E5%80%BC%E5%85%83%E7%B4%A0"><span class="nav-text">2.找出一个数组里的峰值元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%A4%E6%96%ADs%E4%B8%AD%E5%90%AB%E6%9C%89t%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="nav-text">3.判断s中含有t的所有字符的最小子串问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%B1%82%E6%95%B0%E7%BB%84%E5%AE%83%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">4.求数组它的最长递增子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%B1%82%E4%B8%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-text">5.求两字符串的最长公共子序列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%A2%98%E7%9B%AE"><span class="nav-text">6.编辑距离题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E8%A7%A3%E6%B3%95"><span class="nav-text">7.最长回文子序列解法:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">8.最长回文子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-text">9.旋转数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0"><span class="nav-text">10.删除并获得点数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98"><span class="nav-text">11. 高楼扔鸡蛋问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E6%88%B3%E6%B0%94%E7%90%83%E9%97%AE%E9%A2%98"><span class="nav-text">12.戳气球问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E7%9B%AE%E6%A0%87%E5%92%8C%E9%97%AE%E9%A2%98"><span class="nav-text">13.目标和问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="nav-text">14.乘积为正数的最长子数组长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88"><span class="nav-text">15.最佳观光组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-text">16.接雨水</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="nav-text">17.解码方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E4%B8%91%E6%95%B0"><span class="nav-text">18.判断是否是丑数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E6%B1%82%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%95%B0%E7%9B%AE"><span class="nav-text">19.求不同的二叉搜索树数目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">20.矩阵中的路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-text">21.全为1的正方形的最大面积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">数据结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU%E7%BC%93%E5%AD%98"><span class="nav-text">1.实现一个LRU缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALFU%E7%BC%93%E5%AD%98"><span class="nav-text">2.实现一个LFU缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-text">3.用栈实现一个队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E9%80%9A%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="nav-text">解题通用思路</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Kenway"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Kenway</p>
  <div class="site-description" itemprop="description">这世界上的东西，<br>你不去搬它，它就不动 。<br>一张桌子，你不搬它，它不走;<br>一把茶壶，你不拿它，它起不来。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Kenway-20" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Kenway-20" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:UniverseEddy@outlook.com" title="E-Mail → mailto:UniverseEddy@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fas fa-chess-pawn"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kenway</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">感谢你的阅读，全站内容约41.3k字</span>
</div>

<br/>

    <!-- 网站运行时间的设置 -->
    <span id="timeDate">载入天数...</span>
    <span id="times">载入时分秒...</span>  
    <script>
        var now = new Date();
        function createtime() {
            var grt= new Date("06/17/2021 18:03:00");//此处修改你的建站时间或者网站上线时间
            now.setTime(now.getTime()+250);
            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
            document.getElementById("timeDate").innerHTML = "本站建于2021年06月17日，已安全运行 "+dnum+" 天 ";
            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()",250);
    </script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
